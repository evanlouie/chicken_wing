<!DOCTYPE html>

<script src='/js/three/three.min.js'></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.min.js"></script>-->

<script src='/js/three/FirstPersonControls.js'></script>
<!--<script src='threex.dynamictexture.js'></script>-->

<script src='/js/three/CombinedCamera.js'></script>



<style type="text/css">
    body {
        background:#d8e7ff;
        color: #fff;
        padding:0;
        margin:0;
        overflow:hidden;
        font-family: georgia;
        font-size:1em;
        text-align: center;
    }
    #info {
        position: absolute;
        top: 10px; width: 100%;
        padding: 5px;
        text-align: center;
        z-index:100;
    }

    a {
        color: orange;
        text-decoration: none;
    }

    a:hover {
        color: #0080ff;
    }

</style>

<body>
<div id="info">
  Revision: <b id="p1">0</b>
</div>
<script>

    //ALL THE JSON STUFF
    var data = <%= @project.html_safe %>;
    var seed = 0x811c9dc5;

    // MY HASHING FUNCTION
    function hashFnv32a(str, asString, seed) {
        /*jshint bitwise:false */
        var i, l,
                hval = (seed === undefined) ? 0x811c9dc5 : seed;

        for (i = 0, l = str.length; i < l; i++) {
            hval ^= str.charCodeAt(i);
            hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
        }
        if( asString ){
            // Convert to 8 digit hex string
            return ("0000000" + (hval >>> 0).toString(16)).substr(-8);
        }
        return hval >>> 0;
    }



    function getTileCoordinatesx(tileNum){
        var intRoot=Math.floor(Math.sqrt(tileNum));
        var x=(Math.round(intRoot/2)*Math.pow(-1,intRoot+1))+(Math.pow(-1,intRoot+1)*(((intRoot*(intRoot+1))-tileNum)-Math.abs((intRoot*(intRoot+1))-tileNum))/2);
        return x;
    }

    function getTileCoordinatesy(tileNum){
        var intRoot=Math.floor(Math.sqrt(tileNum));
        var y=(Math.round(intRoot/2)*Math.pow(-1,intRoot))+(Math.pow(-1,intRoot+1)*(((intRoot*(intRoot+1))-tileNum)+Math.abs((intRoot*(intRoot+1))-tileNum))/2);

        return y;
    }

    //intialize scene and camera and stuff
    var updateFcts	= [];
    var scene = new THREE.Scene(); // Create a Three.js scene object.
    //scene.fog	= new THREE.FogExp2( 0xd0e0f0, 0.001);
    var camera	= new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.01, 3000) // Define the perspective camera's attributes.
    var renderer = window.WebGLRenderingContext ? new THREE.WebGLRenderer() : new THREE.CanvasRenderer(); // Fallback to canvas renderer, if necessary.
    renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the WebGL viewport.
    document.body.appendChild(renderer.domElement); // Append the WebGL viewport to the DOM.
    camera.position.y = 100
    camera.position.x = -500
    camera.position.z = 0
    camera.setLens (24, 35)


    var light	= new THREE.HemisphereLight( 0xfffff0, 0x101020, 1.25 );
    light.position.set( 0.75, 1, 0.25 );
    scene.add( light );


    // define path and box sides images
    //var path = 'skybox/';
    //var sides = [ path + '1.jpg', path + '2.jpg', path + '3.jpg', path + '4.jpg', path + '5.jpg', path + '6.jpg' ];

    var path = '/images/ely_darkcity/';
    var sides = [ path + 'darkcity_ft.jpg', path + 'darkcity_bk.jpg', path + 'darkcity_up.jpg', path + 'darkcity_dn.jpg', path + 'darkcity_rt.jpg', path + 'darkcity_lf.jpg' ];

    // load images
    var scCube = THREE.ImageUtils.loadTextureCube(sides);
    scCube.format = THREE.RGBFormat;

    // prepare skybox material (shader)
    var skyShader = THREE.ShaderLib["cube"];
    skyShader.uniforms["tCube"].value = scCube;
    var skyMaterial = new THREE.ShaderMaterial( {
        fragmentShader: skyShader.fragmentShader, vertexShader: skyShader.vertexShader,
        uniforms: skyShader.uniforms, depthWrite: false, side: THREE.BackSide
    });

    // create Mesh with cube geometry and add to the scene
    var skyBox = new THREE.Mesh(new THREE.CubeGeometry(2000, 2000, 2000), skyMaterial);
    skyMaterial.needsUpdate = true;
    skyBox.position.y +=800;
    scene.add(skyBox);




    var planematerial	= new THREE.MeshBasicMaterial({ color: 0x000000 })
    var planegeometry	= new THREE.CircleGeometry( 500, 500 )
    var plane	= new THREE.Mesh( planegeometry, planematerial );
    plane.rotation.x= - 90 * Math.PI / 180;
    plane.position.y += -200
    scene.add( plane );


    //intitialize the array with the buildings!
    var ListOfBuildings = [];
    var ListOfBillboards = [];
    //initialize the BIG array, which will contain all the values
    var BIGArray = [];
    //initialize one array for each revision
    for (var i in data.revisions){
        var smallArray = [];
        for (var j in data.revisions[i].items){
            smallArray.push(data.revisions[i].items[j]);
        }
        BIGArray.push(smallArray);
    }

    //initialize a variable to keep track of revision (REVISIONID)
    var revisionID = 0;
    var buildingNUM = 0; // <--- used to make sure that new buildings do not overlap old building positions!

    var building = new THREE.CubeGeometry( 1, 1, 1);
    building.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );
    // get rid of the bottom face - it is never seen
    building.faces.splice( 3, 1 );
    building.faceVertexUvs[0].splice( 3, 1 );
    // change UVs for the top face
    // - it is the roof so it wont use the same texture as the side of the building
    // - set the UVs to the single coordinate 0,0. so the roof will be the same color
    //   as a floor row.
    building.faceVertexUvs[0][2][0].set( 0, 0 );
    building.faceVertexUvs[0][2][1].set( 0, 0 );
    building.faceVertexUvs[0][2][2].set( 0, 0 );
    building.faceVertexUvs[0][2][3].set( 0, 0 );
    // buildMesh

    // base colors for vertexColors. light is for vertices at the top, shaddow is for the ones at the bottom
    var light	= new THREE.Color( 0xffffff )
    var shadow	= new THREE.Color( 0x303050 )

    // generate the texture
    //	var texture		= new THREE.Texture( generateTextureCanvas() );
    //	texture.anisotropy	= renderer.getMaxAnisotropy();
    //	texture.needsUpdate	= true;

    // generate a second texture
    var createTexture_window = function(y_stack){
        var texture_new   = THREE.ImageUtils.loadTexture('HighRise.jpg');
        texture_new.wrapS = THREE.RepeatWrapping;
        texture_new.wrapT = THREE.RepeatWrapping;
        texture_new.repeat.set( 1, y_stack );
        texture_new.needsUpdate = true;
        return texture_new;
    }

    // build the mesh
    var material	= new THREE.MeshLambertMaterial({
        //map		: createTexture_window(1),
        vertexColors	: THREE.VertexColors
    });

    function generateTextureCanvas(){
        // build a small canvas 32x64 and paint it in white
        var canvas	= document.createElement( 'canvas' );
        canvas.width	= 10;
        canvas.height	= 10;
        var context	= canvas.getContext( '2d' );
        context.fillStyle	= '#ffffff';
        context.fillRect( 0, 0, 64, 128 );
        // draw the window rows - with a small noise to simulate light variations in each room
        for( var y = 2; y < 128; y += 2 ){
            for( var x = 0; x < 64; x += 2 ){
                var value	= Math.floor( Math.random() * 128 );
                context.fillStyle = 'rgb(' + [value, value, value].join( ',' )  + ')';
                context.fillRect( x, y, 2, 1 );
            }
        }

        // build a bigger canvas and copy the small one in it
        // This is a trick to upscale the texture without filtering
        var canvas2	= document.createElement( 'canvas' );
        canvas2.width	= 512;
        canvas2.height	= 1024;
        var context	= canvas2.getContext( '2d' );
        // disable smoothing
        context.imageSmoothingEnabled		= false;
        context.webkitImageSmoothingEnabled	= false;
        context.mozImageSmoothingEnabled	= false;
        // then draw the image
        context.drawImage( canvas, 0, 0, canvas2.width, canvas2.height );
        // return the just built canvas2
        //canvas2.add(ground);
        return canvas2;
    }



    //var material = new THREE.MeshBasicMaterial({ color: 0x0000FF });
    //var buildingMesh = new THREE.Mesh(building,material);
    /*var cubeMaterials = [
     new THREE.MeshBasicMaterial({color:0x33AA55, transparent:true, opacity:0.8}),
     new THREE.MeshBasicMaterial({color:0x55CC00, transparent:true, opacity:0.8}),
     new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.8}),
     new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:0.8}),
     new THREE.MeshBasicMaterial({color:0x0000FF, transparent:true, opacity:0.8}),
     new THREE.MeshBasicMaterial({color:0x5555AA, transparent:true, opacity:0.8}),
     ];
     var material = new THREE.MeshFaceMaterial(cubeMaterials);
     */

    var createBuilding = function (y,color) {
        var building = new THREE.CubeGeometry( 1, 1, 1);
        building.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );
        // get rid of the bottom face - it is never seen
        building.faces.splice( 3, 1 );
        building.faceVertexUvs[0].splice( 3, 1 );
        // change UVs for the top face
        // - it is the roof so it wont use the same texture as the side of the building
        // - set the UVs to the single coordinate 0,0. so the roof will be the same color
        //   as a floor row.
        building.faceVertexUvs[0][2][0].set( 0, 0 );
        building.faceVertexUvs[0][2][1].set( 0, 0 );
        building.faceVertexUvs[0][2][2].set( 0, 0 );
        building.faceVertexUvs[0][2][3].set( 0, 0 );


        var buildingMesh = new THREE.Mesh(building,material);
        buildingMesh.position.x	= getTileCoordinatesx(buildingNUM)*25;
        buildingMesh.position.z	= getTileCoordinatesy(buildingNUM)*25;
        buildingNUM++;
        buildingMesh.scale.x	= 15;
        buildingMesh.scale.y	= y;
        buildingMesh.scale.z	= buildingMesh.scale.x;

        var baseColor	= new THREE.Color().setRGB(1, color, color);
        var topColor	= baseColor.clone().multiply( light );
        var bottomColor	= baseColor.clone().multiply( shadow );

        for ( var j = 0, jl = buildingMesh.geometry.faces.length; j < jl; j ++ ) {
            if ( j === 2 ) {
                buildingMesh.geometry.faces[ j ].vertexColors = [ baseColor, baseColor, baseColor, baseColor ];
                //buildingMesh.material.map = createTexture_window(Math.floor(y/10));
                //buildingMesh.material.needsUpdate = true;
            } else {
                // set face.vertexColors on sides faces
                buildingMesh.geometry.faces[ j ].vertexColors = [ topColor, bottomColor, bottomColor, topColor ];
            }
        }
        buildingMesh.geometry.colorsNeedUpdate = true;

        buildingMesh.position.y -= 200;

        return buildingMesh;
    }

    var createBillboard = function(y) {
        var billboard = new THREE.CubeGeometry(1,1,1);
        billboard.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 0.5, 0 ) );
        // get rid of the bottom face - it is never seen
        billboard.faces.splice( 3, 1 );
        billboard.faceVertexUvs[0].splice( 3, 1 );
        // change UVs for the top face
        // - it is the roof so it wont use the same texture as the side of the billboard
        // - set the UVs to the single coordinate 0,0. so the roof will be the same color
        //   as a floor row.
        billboard.faceVertexUvs[0][2][0].set( 0, 0 );
        billboard.faceVertexUvs[0][2][1].set( 0, 0 );
        billboard.faceVertexUvs[0][2][2].set( 0, 0 );
        billboard.faceVertexUvs[0][2][3].set( 0, 0 );


        var billboardMesh = new THREE.Mesh(billboard,material);
        billboardMesh.position.x  = getTileCoordinatesx(buildingNUM - 1)*25;
        billboardMesh.position.z  = getTileCoordinatesy(buildingNUM - 1)*25;
        billboardMesh.position.y = y;
        billboardMesh.scale.x = 15;
        billboardMesh.scale.y = 10;
        billboardMesh.scale.z = 2;

        billboardMesh.position.y -= 200;

        return billboardMesh;
    }

    var initialize = function () {
        // INITIALIZE THE CITY!!
        document.addEventListener( 'keydown', onKeyDown, false );

        for( var i = 0; i < BIGArray[revisionID].length; i++ ){
            var y = BIGArray[revisionID][i].line_count;
            var color=0;
            if (BIGArray[revisionID][i].smell_count<BIGArray[revisionID][i].line_count){
                color = 1-BIGArray[revisionID][i].smell_count/BIGArray[revisionID][i].line_count;
            }
            var buildingMesh = createBuilding(y,color);
            var billboard = createBillboard(y);


            ListOfBuildings[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)] = buildingMesh;
            ListOfBillboards[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)] = billboard;
            // add it to the scene
            scene.add(buildingMesh);
            scene.add(billboard);
        }

    };

    initialize();



    //initialize difference HASH table
    var buildingDifference = [];

    // update ListOfBuildings

    function updateBuildingList(){

        for( var i = 0; i < BIGArray[revisionID].length; i ++ ){
            // if building does not exist yet, BUILD IT!
            if (ListOfBuildings[hashFnv32a(BIGArray[revisionID][i].trackable_name,false, seed)] == null){
                var y = 0
                //var color = 1-BIGArray[revisionID][i].smell_count*1/5;
                var color=0;
                if (BIGArray[revisionID][i].smell_count<BIGArray[revisionID][i].line_count){
                    color = 1-BIGArray[revisionID][i].smell_count/BIGArray[revisionID][i].line_count;
                }
                var buildingMesh = createBuilding(y,color);
                var billboard = createBillboard(y);

                // add building to list of buildings
                ListOfBuildings[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)] = buildingMesh;
                ListOfBillboards[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)] = billboard;
                // add it to the scene
                scene.add(buildingMesh);
                scene.add(billboard);
            }
            // calculate the difference between current and last revision for line_count and smell_count
            var diff_lc = - (ListOfBuildings[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)].scale.y - BIGArray[revisionID][i].line_count) / TRACKER_MAX;
            var new_sc = BIGArray[revisionID][i].smell_count;
            var hashval_ = hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed);
            var differences = {lc: diff_lc, sc: new_sc, hashval: hashval_};
            buildingDifference[hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed)] = differences;

            // TODO: NEED TO REMOVE BUILDINGS THAT NO LONGER EXIST HERE:

        }

    }

    // to keep track of the 10 iterations
    var tracker = TRACKER_MAX;


    //renderer.render(scene,camera);



    //////////////////////////////////////////////////////////////////////////////////
    //		Camera Controls							//
    //////////////////////////////////////////////////////////////////////////////////
    var controls	= new THREE.FirstPersonControls( camera );
    controls.movementSpeed	= 100;
    controls.lookSpeed	= 0.05;
    controls.lookVertical	= true;
    updateFcts.push(function(delta, now){
        controls.update( delta );
    })

    //////////////////////////////////////////////////////////////////////////////////
    //		render the scene						//
    //////////////////////////////////////////////////////////////////////////////////
    updateFcts.push(function(){
        renderer.render( scene, camera );
    })

    //////////////////////////////////////////////////////////////////////////////////
    //		loop runner							//
    //////////////////////////////////////////////////////////////////////////////////
    var lastTimeMsec= null
    var TRACKER_MAX = 25;

    requestAnimationFrame(function animate(nowMsec){
        if (revisionID < BIGArray.length){
            if (tracker == TRACKER_MAX){
                revisionID++;
                document.getElementById("p1").innerHTML = revisionID;
            }
            // change the building height if tracker is less than 10, otherwise update the building list and reset the tracker!
            if (tracker < TRACKER_MAX){
                var rev = revisionID;
                var lala = BIGArray[revisionID].length;
                for( var i = 0; i < BIGArray[revisionID].length; i++){
                    var key = hashFnv32a(BIGArray[revisionID][i].trackable_name,false,seed);
                    ListOfBuildings[key].scale.y += buildingDifference[key].lc; // update the height of ONLY the ones who are in this current revision!
                    ListOfBillboards[key].position.y += buildingDifference[key].lc;
                    // update smell count color
                    var color=0;
                    if (BIGArray[revisionID][i].smell_count<BIGArray[revisionID][i].line_count){
                        color = 1-BIGArray[revisionID][i].smell_count/BIGArray[revisionID][i].line_count;
                    }
                    var baseColor	= new THREE.Color().setRGB(1, color, color);
                    var topColor	= baseColor.clone().multiply( light );
                    var bottomColor	= baseColor.clone().multiply( shadow );

                    for ( var j = 0, jl = ListOfBuildings[key].geometry.faces.length; j < jl; j ++ ) {
                        if ( j === 2 ) {
                            // set face.vertexColors on root face
                            ListOfBuildings[key].geometry.faces[ j ].vertexColors = [ baseColor, baseColor, baseColor, baseColor ];
                            ListOfBuildings[key].geometry.colorsNeedUpdate = true;
                            // by creating a material at each render makes view super laggy
                            //ListOfBuildings[key].material.map = createTexture_window(Math.floor(buildingDifference[key].lc/10));
                            //ListOfBuildings[key].material.map.repeat.set(1,Math.floor(ListOfBuildings[key].scale.y/10))
                            //ListOfBuildings[key].material.needsUpdate = true;
                        } else {
                            // set face.vertexColors on sides faces
                            ListOfBuildings[key].geometry.faces[ j ].vertexColors = [ topColor, bottomColor, bottomColor, topColor ];
                            ListOfBuildings[key].geometry.colorsNeedUpdate = true;
                        }
                    }

                }
                tracker++;
            }
            else{
                if (revisionID < BIGArray.length){
                    updateBuildingList();
                    tracker = 0;
                }
            }
        }

        requestAnimationFrame(animate);
        // measure time
        lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
        var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
        lastTimeMsec	= nowMsec
        // call each update function
        updateFcts.forEach(function(updateFn){
            updateFn(deltaMsec/1000, nowMsec/1000)
        })
        //Make each Billboard face the camera
        Object.keys(ListOfBillboards).forEach(function(key){
            ListOfBillboards[key].lookAt(camera.position);
        })
    })

    function onKeyDown ( event ) {
        if(event.keyCode==67) {
            
          if(camera.inOrthographicMode){
            camera.toPerspective();
            controls = fpcontrols;
          }
          else{
            camera.toOrthographic();
            controls = obcontrols;
          }

          camera.position.y = 0;
          camera.position.x = 0;
          camera.position.z = 0;
        }
    };

</script>
</body>
</html>
		
			